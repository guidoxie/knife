package log

// 打印 Debug 级别的日志
// 如名字 de-bug 所述，该级别的日志主要用于捉虫、调试Bug，故主要在调试期间对系统每一步的运行状态进行精确的记录。
// 在生产环境中通常都不会打印该级别的日志。
func Debug(args ...interface{}) {
	logger.Debug(args...)
}

// 打印 Debug 级别的日志
// 如名字 de-bug 所述，该级别的日志主要用于捉虫、调试Bug，故主要在调试期间对系统每一步的运行状态进行精确的记录。
// 在生产环境中通常都不会打印该级别的日志。
func Debugf(format string, args ...interface{}) {
	logger.Debugf(format, args...)
}

// 打印 Info 级别的日志
// 该级别的日志主要用于记录系统运行状态、核心用例执行结果、用户的操作行为等信息，常用于反馈系统当前状态给最终用户。
//
// Info 级别日志的包括但不限于以下几种情况：
//    接口请求与响应。通常情况下，只要涉及到微服务间的访问，都要打印入参与出参。
//    一些需要观测执行情况的行为：如定时任务（尤其是分布式任务）等/大批量数据执行进度（批处理）/耗时操作等等
//    不符合业务逻辑预期（尤其核心业务）：打印关键的参数，要能从这些参数中清楚地看出，谁的操作与预期不符，为什么与预期不符。并且唯一定位到这条日志，要包含用户id或者流水号
//    系统模块的入口与出口处：可以是重要方法级或模块级，记录它的输入与输出，方便定位
//    服务状态变化(尽可能记录线索)：程序中重要的状态信息的变化应该记录下来，方便查问题时还原现场，推断程序运行过程
//    程序运行耗时：通过它可以跟踪为什么系统响应变慢或者太快。再配合链路追踪系统，可以方便的定位到那个系统哪个方法耗时长
func Info(args ...interface{}) {
	logger.Info(args...)
}

// 打印 Info 级别的日志
// 该级别的日志主要用于记录系统运行状态、核心用例执行结果、用户的操作行为等信息，常用于反馈系统当前状态给最终用户。
//
// Info 级别日志的包括但不限于以下几种情况：
//    接口请求与响应。通常情况下，只要涉及到微服务间的访问，都要打印入参与出参。
//    一些需要观测执行情况的行为：如定时任务（尤其是分布式任务）等/大批量数据执行进度（批处理）/耗时操作等等
//    不符合业务逻辑预期（尤其核心业务）：打印关键的参数，要能从这些参数中清楚地看出，谁的操作与预期不符，为什么与预期不符。并且唯一定位到这条日志，要包含用户id或者流水号
//    系统模块的入口与出口处：可以是重要方法级或模块级，记录它的输入与输出，方便定位
//    服务状态变化(尽可能记录线索)：程序中重要的状态信息的变化应该记录下来，方便查问题时还原现场，推断程序运行过程
//    程序运行耗时：通过它可以跟踪为什么系统响应变慢或者太快。再配合链路追踪系统，可以方便的定位到那个系统哪个方法耗时长
func Infof(format string, args ...interface{}) {
	logger.Infof(format, args...)
}

// 打印 Warn 级别的日志。
// 该级别的日志表示系统出现了预期外的、不应该出现的情况，但是该情况不影响程序或当前请求正常运行。
// 对于 WARN 级别的日志，虽然不需要马上处理，但是也需要引起重视。
//
// Warn 级别日志的包括但不限于以下几种情况：
//    异常：由于在程序运行之前不能明确异常引发的原因，异常只进行了简单的捕获抛出，需要将这种笼统处理的异常打印为Warn格式的日志。不过如果是核心业务，则需要打印Error级别
//    有容错机制的时候出现的错误情况
//    找不到配置文件，但是系统能自动创建配置文件（或使用默认配置）
//    性能即将接近临界值的时候（也要看是否是核心系统，核心业务，如果是，则需要打印Error，报警，并自动或人工扩容）
//    业务异常的记录，危险操作
//    限流，降级，熔断的操作，都需要Warn级别日志打印
//    出于提醒目的的日志。比如2B的业务中，用户数据不完善， 但不至于严重到系统（接口）不可用程度，此时就应该打印Warn级别的日志，然后通知业务方进行数据补全。
func Warn(args ...interface{}) {
	logger.Warn(args...)
}

// 打印 Warn 级别的日志。
// 该级别的日志表示系统出现了预期外的、不应该出现的情况，但是该情况不影响程序或当前请求正常运行。
// 对于 WARN 级别的日志，虽然不需要马上处理，但是也需要引起重视。
//
// 需要打印 Warn 级别日志的包括但不限于以下几种情况：
//    异常：由于在程序运行之前不能明确异常引发的原因，异常只进行了简单的捕获抛出，需要将这种笼统处理的异常打印为Warn格式的日志。不过如果是核心业务，则需要打印Error级别
//    有容错机制的时候出现的错误情况
//    找不到配置文件，但是系统能自动创建配置文件（或使用默认配置）
//    性能即将接近临界值的时候（也要看是否是核心系统，核心业务，如果是，则需要打印Error，报警，并自动或人工扩容）
//    业务异常的记录，危险操作
//    限流，降级，熔断的操作，都需要Warn级别日志打印
//    出于提醒目的的日志。比如2B的业务中，用户数据不完善， 但不至于严重到系统（接口）不可用程度，此时就应该打印Warn级别的日志，然后通知业务方进行数据补全。
func Warnf(format string, args ...interface{}) {
	logger.Warnf(format, args...)
}

// 打印 Error 级别的日志。
// 该级别的错误需要马上被处理，当Error错误发生时，已经影响了用户的正常访问，是需要马上介入并处理的。
// 常见的Error异常有：空指针异常，数据库不可用，服务不可用，关键用例无法继续执行等。
//
// Error是错误的意思，但不代表出现异常的地方就该打Error。
// Error是相对程序正确运行来说的，如果出现了Error那就代表出问题了，开发人员必须要查一下原因，或许是程序问题，或许是环境问题，或许是理论上不该出错的地方出错了。
// 总之，如果你觉得某个地方出问题时需要解决，就打Error，如果不需要解决就不要打Error。
func Error(args ...interface{}) {
	logger.Error(args...)
}

// 打印 Error 级别的日志。
// 该级别的错误需要马上被处理，当Error错误发生时，已经影响了用户的正常访问，是需要马上介入并处理的。
// 常见的Error异常有：空指针异常，数据库不可用，服务不可用，关键用例无法继续执行等。
//
// Error是错误的意思，但不代表出现异常的地方就该打Error。
// Error是相对程序正确运行来说的，如果出现了Error那就代表出问题了，开发人员必须要查一下原因，或许是程序问题，或许是环境问题，或许是理论上不该出错的地方出错了。
// 总之，如果你觉得某个地方出问题时需要解决，就打Error，如果不需要解决就不要打Error。
func Errorf(format string, args ...interface{}) {
	logger.Errorf(format, args...)
}

// Fatal 代表系统中出现了致命错误。
// 调用该方法将会在记录日志后退出进程。
func Fatal(args ...interface{}) {
	logger.Fatal(args...)
}

// Fatal 代表系统中出现了致命错误。
// 调用该方法将会在记录日志后退出进程。
func Fatalf(format string, args ...interface{}) {
	logger.Fatalf(format, args...)
}

func Panic(args ...interface{}) {
	logger.Panic(args...)
}

func Panicf(format string, args ...interface{}) {
	logger.Panicf(format, args...)
}

// 捕获panic
func Recover(msg ...string) {
	out := make([]interface{}, 0)
	for _, m := range msg {
		out = append(out, m)
	}
	if p := recover(); p != nil {
		out = append(out, p)
		logger.Error(out)
	}
}

func Sync() error {
	return logger.Sync()
}
